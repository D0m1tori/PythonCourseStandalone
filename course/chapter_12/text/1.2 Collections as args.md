### Коллекции как параметр функции

Функции могут принимать в качестве параметра коллекции, например списки. Например следующая функция принимает в качестве аргумента два списка и возвращает тот список в котором максимальный элемент больше:

```python
def list_with_larger_max(lst1, lst2):
    if max(lst1) > max(lst2):
        return lst1
    else:
        return lst2

# Пример использования
list1 = [1, 2, 3, 4, 5]
list2 = [10, 2, 3]

result = list_with_larger_max(list1, list2)
print(result)  # [10, 2, 3]
```

### Изменяемость

Изменяемость объектов в Python можно проиллюстрировать с помощью функции `id()`, которая возвращает уникальный идентификатор объекта в памяти. Изменяемые и неизменяемые объекты ведут себя по-разному при попытке их обновления. Изменяемые объекты, такие как списки, могут быть изменены без создания нового объекта, в то время как неизменяемые объекты, такие как кортежи, при изменении создают новые объекты.

### Пример с кортежами (неизменяемые объекты)

Кортежи являются неизменяемыми объектами, поэтому любые операции, которые изменяют кортеж, фактически создают новый объект в памяти, а не обновляют существующий.

```python
# Создаем кортеж
tuple_a = (1, 2, 3)
print("ID до изменения:", id(tuple_a))

# Попробуем "изменить" кортеж (на самом деле, создаем новый)
tuple_a += (4,)
print("ID после изменения:", id(tuple_a))
```

**Вывод:**
```
ID до изменения: 140545629992896
ID после изменения: 140545630021184
```

**Объяснение:**  
Когда мы "добавляем" элемент в кортеж, на самом деле создаётся новый кортеж с другим `id`. Это происходит потому, что кортежи неизменяемы — нельзя изменить их элементы или длину напрямую, и любые такие попытки приводят к созданию нового объекта.

---

### Пример со списками (изменяемые объекты)

Списки являются изменяемыми объектами. Это означает, что операции добавления элементов или изменения существующих элементов не создают новый объект, а модифицируют текущий.

```python
# Создаем список
list_a = [1, 2, 3]
print("ID до изменения:", id(list_a))

# Добавляем элемент в список
list_a.append(4)
print("ID после добавления элемента:", id(list_a))
```

**Вывод:**
```
ID до изменения: 140545630084864
ID после добавления элемента: 140545630084864
```

**Объяснение:**  
Список расширился (мы добавили элемент), но его `id` не изменился. Это демонстрирует, что списки являются изменяемыми объектами — они могут изменяться без создания нового объекта в памяти.


### Особенности передачи коллекций в качестве параметров функций в Python

В Python коллекции (такие как списки, словари, множества, кортежи и другие) могут передаваться в функции в качестве аргументов. Важно понимать, как ведут себя коллекции при передаче в функции, так как это может влиять на изменение данных внутри и снаружи функции.

#### 1. **Передача по ссылке**

Коллекции в Python передаются по **ссылке**, а не по значению. Это означает, что если коллекция передана в функцию, то передается информация не о данных внутри коллекции, а ссылка в памяти на саму коллекцию. Если внутри функции изменяется элемент коллекции, то изменения будут видны и за пределами функции.

**Пример с изменяемым объектом (списком):**
```python
def add_item(my_list):
    my_list.append(4)

lst = [1, 2, 3]
add_item(lst)
print(lst)  # [1, 2, 3, 4]
```
В данном примере функция `add_item()` изменяет список `lst` через его ссылку. После вызова функции список за пределами функции также изменился.


#### 2. **Изменение внутри функции с использованием `copy()`**

Если нужно передать коллекцию в функцию, но избежать изменения оригинала, можно использовать метод **`copy()`** или модуль **`copy`** для глубокого копирования сложных объектов.

**Пример с копированием списка:**
```python
def add_item_copy(my_list):
    my_list_copy = my_list.copy()  # создаем копию
    my_list_copy.append(4)

lst = [1, 2, 3]
add_item_copy(lst)
print(lst)  # [1, 2, 3]
```
Здесь изменяется копия списка внутри функции, и исходный список остаётся неизменным.

#### 3. **Модификация вложенных коллекций**

Даже если вы используете копирование коллекций, изменённые вложенные элементы всё равно могут изменять исходную коллекцию, если не было сделано **глубокое копирование**.

**Пример с вложенными списками:**
```python
import copy

def modify_nested(my_list):
    my_list_copy = copy.deepcopy(my_list)  # глубокое копирование
    my_list_copy[0][0] = 999

lst = [[1, 2], [3, 4]]
modify_nested(lst)
print(lst)  # [[1, 2], [3, 4]] - оригинальный список не изменился
```

#### 4. **Изменение структуры словарей**

Словари передаются аналогично спискам: передача происходит по ссылке. Изменения словаря в функции также повлияют на исходный словарь.

**Пример:**
```python
def modify_dict(d):
    d["new_key"] = "new_value"

data = {"key1": "value1", "key2": "value2"}
modify_dict(data)
print(data)  # {'key1': 'value1', 'key2': 'value2', 'new_key': 'new_value'}
```

Здесь добавление нового ключа в словарь внутри функции изменяет оригинальный словарь.